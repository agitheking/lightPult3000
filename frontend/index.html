<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BÃ¼hnenâ€‘Lichtsteuerung Â· Viertelkreis</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='8' cy='8' r='6' fill='%238b5cf6'/%3E%3C/svg%3E"/>

  <!-- React/Babel/Tailwind (Dev) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js?v=2"></script>
  <link href="https://unpkg.com/@tailwindcss/ui/dist/tailwind-ui.min.css" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { background: #0b1220; color: #e5e7eb; }
    .card { background: rgba(15,23,42,.6); border:1px solid #334155; border-radius:16px; padding:16px; }
    .btn { border:1px solid #334155; border-radius:12px; padding:8px 12px; background:#0b1220; }
    .btn:hover { background:#0f172a; }
    .pill { border:1px solid #334155; padding:2px 8px; border-radius:999px; font-size:12px;}
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .grid1 { display:grid; grid-template-columns: 1fr; gap: 16px; }
    .kachel { border:1px solid #334155; border-radius:16px; padding:16px; cursor:pointer; }
    .kachel:hover { background:#0f172a; }
    .muted { opacity:.6; pointer-events:none; }
  </style>
</head>
<body class="p-6">
  <div id="app"></div>

  <script type="text/babel">
/** React Hooks */
const { useState, useEffect, useMemo, useRef } = React;

/** Shims (keine AbhÃ¤ngigkeit auf Motion) */
const motion = (props) => props.children;
const AnimatePresence = React.Fragment;

const MODES = ["editor","probe","show","guest"];
const TYPES = ["DIM","RGB"];
const THEMES = ["realistic","comic","theater"];

const LS = {
  theme:"q_theme", lights:"q_lights", scenes:"q_scenes",
  playlist:"q_playlist", auto:"q_auto", mode:"q_mode"
};

const METER_TO_PX = 100;
const RADIUS_M = 4;
const R = RADIUS_M * METER_TO_PX;

/* ðŸ‘‰ ViewBox so, dass der linke untere Quadrant sichtbar ist */
const VIEWBOX = { x: -(R+120), y: -20, w: R+120, h: R+120 };

function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
function len(x,y){ return Math.sqrt(x*x+y*y); }
function uid(p){ return p+"_"+Math.random().toString(36).slice(2,9); }
function distributeAngles(n){ if(n<=1) return [45]; const a=8, b=82, s=(b-a)/(n-1); return Array.from({length:n},(_,i)=>Math.round(a+i*s)); }
function toRad(d){ return d*Math.PI/180; }
function toDeg(r){ return r*180/Math.PI; }

function makeInitialLights(n){
  const angles  = distributeAngles(n); // 8..82Â°
  const palette = ["#ffd166","#90cdf4","#f56565","#c084fc","#4ade80",
                   "#f59e0b","#22d3ee","#a3e635","#fb7185","#f472b6",
                   "#60a5fa","#facc15"];

  const marginOut    = 32;  // leicht vor dem BÃ¼hnenrand (auÃŸen)
  const insideOffset = 70;  // drei Spots nach innen
  const insideIdx    = new Set([1, 6, 11]); // welche drei (0â€‘basiert)

  return angles.map((a, i) => {
    const rad = toRad(a);

    // Punkt AUF dem linken unteren Viertelkreis:
    // rad=0 -> (0,R) (SÃ¼d), rad=90Â° -> (-R,0) (West)
    const onR = { x: -R * Math.sin(rad), y: R * Math.cos(rad) };

    // radialer Normalâ€‘Vektor (nach auÃŸen, bereits normiert)
    const nrm = { x: onR.x / R, y: onR.y / R };

    // Standard: Spots ein StÃ¼ck vor dem Rand (Publikumsseite)
    let x = onR.x + nrm.x * marginOut;
    let y = onR.y + nrm.y * marginOut;

    // Drei Spots nach innen in die BÃ¼hne
    if (insideIdx.has(i)) {
      x = onR.x - nrm.x * insideOffset;
      y = onR.y - nrm.y * insideOffset;
    }

    // Standardâ€‘Richtung: zum Zentrum (Beam zeigt in die BÃ¼hne)
    const dirDeg = (toDeg(Math.atan2(-y, -x)) + 360) % 360;

    return {
      id:"L"+(i+1), label:"Spot "+(i+1),
      type: i%4===0 ? "RGB" : "DIM",
      angleDeg:a, x, y,
      brightness:60, r:255, g:200, b:120,
      color: palette[i % palette.length],
      dmx:{universe:0, start:1+i*4, mode:"std"},
      dirDeg // <â€” Drehwinkel des Lichtkegels
    };
  });
}

function beamColor(l){
  if(l.type==="RGB"){
    const s=l.brightness/100, r=Math.round(l.r*s), g=Math.round(l.g*s), b=Math.round(l.b*s);
    return `rgb(${r},${g},${b})`;
  }
  return l.color;
}

function buildDMXChannels(lights){
  const channels = [];
  lights.forEach(l => {
    if(l.type==="DIM"){
      const v = Math.round(255*(l.brightness/100));
      channels.push({address: l.dmx.start, value: v});
    } else {
      const s = l.brightness/100;
      channels.push({address: l.dmx.start,   value: Math.round(l.r*s)});
      channels.push({address: l.dmx.start+1, value: Math.round(l.g*s)});
      channels.push({address: l.dmx.start+2, value: Math.round(l.b*s)});
    }
  });
  return channels;
}

/* Hilfsfunktionen fÃ¼r Rotationsâ€‘UI */
function pointOnCircle(cx,cy,r,deg){
  return { x: cx + r*Math.cos(toRad(deg)), y: cy + r*Math.sin(toRad(deg)) };
}
function angleFromPoint(cx,cy,px,py){
  return (toDeg(Math.atan2(py - cy, px - cx)) + 360) % 360;
}
function arcPath(cx,cy,r,a1,a2){
  const x1 = cx + r * Math.cos(toRad(a1));
  const y1 = cy + r * Math.sin(toRad(a1));
  const x2 = cx + r * Math.cos(toRad(a2));
  const y2 = cy + r * Math.sin(toRad(a2));
  const da = ((a2 - a1 + 360) % 360);
  const large = da > 180 ? 1 : 0;
  const sweep = 1; // immer â€žvorwÃ¤rtsâ€œ
  return `M ${x1} ${y1} A ${r} ${r} 0 ${large} ${sweep} ${x2} ${y2}`;
}

function App(){
  const [mode, setMode] = useState(localStorage.getItem(LS.mode)||"editor");
  const [theme, setTheme] = useState(localStorage.getItem(LS.theme)||"realistic");
  const [lights, setLights] = useState(()=>{
    const s = localStorage.getItem(LS.lights);
    let ls = s ? JSON.parse(s) : makeInitialLights(14);
    // Autoâ€‘Migration: dirDeg ergÃ¤nzen & bei altem Layout ggf. spiegeln
    ls = ls.map(l => ({
      ...l,
      dirDeg: (typeof l.dirDeg === "number") ? l.dirDeg
               : (toDeg(Math.atan2(-l.y, -l.x)) + 360) % 360
    }));
    const right = ls.filter(l => l.x > 0).length;
    if (right > ls.length / 2) {
      ls = ls.map(l => ({ ...l, x: -Math.abs(l.x) }));
    }
    return ls;
  });
  const [scenes, setScenes] = useState(()=>{
    const s = localStorage.getItem(LS.scenes);
    return s? JSON.parse(s): [];
  });
  const [playlist, setPlaylist] = useState(()=>{
    const s = localStorage.getItem(LS.playlist);
    return s? JSON.parse(s): [];
  });
  const [auto, setAuto] = useState(()=> Number(localStorage.getItem(LS.auto)||5));
  const [playing, setPlaying] = useState(false);
  const [currentIdx, setCurrentIdx] = useState(0);

  const [selectedId, setSelectedId] = useState(null);
  const [dragId, setDragId] = useState(null);
  const [rotId, setRotId] = useState(null);
  const [hoverId, setHoverId] = useState(null);

  const svgRef = useRef(null);

  useEffect(()=>localStorage.setItem(LS.mode,mode),[mode]);
  useEffect(()=>localStorage.setItem(LS.theme,theme),[theme]);
  useEffect(()=>localStorage.setItem(LS.lights,JSON.stringify(lights)),[lights]);
  useEffect(()=>localStorage.setItem(LS.scenes,JSON.stringify(scenes)),[scenes]);
  useEffect(()=>localStorage.setItem(LS.playlist,JSON.stringify(playlist)),[playlist]);
  useEffect(()=>localStorage.setItem(LS.auto,String(auto)),[auto]);

  const caps = useMemo(()=> ({
    canEdit: mode!=="show" && mode!=="guest",
    showPlaylist: mode!=="editor" && mode!=="guest",
    reorder: mode==="probe",
    addRemove: mode==="probe",
    sceneSaveDelete: mode!=="show" && mode!=="guest",
    importExport: mode!=="show" && mode!=="guest",
    playerControls: mode!=="editor",
    autoEdit: mode!=="show" && mode!=="guest",
  }),[mode]);

  function setBrightness(id, v){ if(!caps.canEdit) return; setLights(ls=>ls.map(l=>l.id===id? {...l,brightness:Number(v)}:l)); }
  function setRGB(id, key, v){ if(!caps.canEdit) return; setLights(ls=>ls.map(l=>l.id===id? {...l,[key]:Number(v)}:l)); }
  function setType(id, t){ if(!caps.canEdit) return; setLights(ls=>ls.map(l=>l.id===id? {...l,type:t}:l)); }
  function renameLight(id, name){ if(!caps.canEdit) return; setLights(ls=>ls.map(l=>l.id===id? {...l,label:name}:l)); }
  function setDMX(id, patch){ if(!caps.canEdit) return; setLights(ls=>ls.map(l=>l.id===id? {...l, dmx:{...l.dmx, ...patch}}:l)); }

  function saveScene(name){ if(!caps.sceneSaveDelete||!name) return;
    setScenes(ss=>[{id:"S"+Date.now(), name, lights}, ...ss]);
  }
  function applyScene(id){
    const s = scenes.find(sc=>sc.id===id);
    if(!s) return;
    setLights(s.lights);
    setSelectedId(s.lights[0]?.id||"");
    sendDMX(buildDMXChannels(s.lights));
  }
  function deleteScene(id){ if(!caps.sceneSaveDelete) return; setScenes(ss=>ss.filter(s=>s.id!==id)); }

  function addToPlaylist(sceneId){ if(!caps.addRemove) return;
    const s = scenes.find(sc=>sc.id===sceneId); if(!s) return;
    setPlaylist(pl=>[...pl,{pid:uid("P"),sceneId:s.id,name:s.name}]);
  }
  function rmFromPlaylist(pid){ if(!caps.addRemove) return; setPlaylist(pl=>pl.filter(p=>p.pid!==pid)); }
  function clearPlaylist(){ if(!caps.addRemove) return; setPlaylist([]); setCurrentIdx(0); }

  const [dragPid, setDragPid] = useState(null);
  function onDragStart(e,pid){ if(!caps.reorder) return; setDragPid(pid); e.dataTransfer.effectAllowed="move"; }
  function onDragOver(e,over){ if(!caps.reorder) return; e.preventDefault();
    if(dragPid===null || dragPid===over) return;
    const src = playlist.findIndex(p=>p.pid===dragPid);
    const dst = playlist.findIndex(p=>p.pid===over);
    if(src<0||dst<0) return;
    const next=[...playlist]; const [m]=next.splice(src,1); next.splice(dst,0,m); setPlaylist(next);
  }
  function onDrop(){ if(!caps.reorder) return; setDragPid(null); }

  function applyPlaylistIndex(i){
    if(!playlist.length) return;
    const idx = ((i%playlist.length)+playlist.length)%playlist.length;
    setCurrentIdx(idx);
    const entry = playlist[idx];
    applyScene(entry.sceneId);
  }
  function nextScene(){ if(playlist.length) applyPlaylistIndex(currentIdx+1); }
  function prevScene(){ if(playlist.length) applyPlaylistIndex(currentIdx-1); }

  useEffect(()=>{
    if(!caps.showPlaylist || !playing || !playlist.length) return;
    const h = setInterval(()=>nextScene(), Math.max(1,auto)*1000);
    return ()=>clearInterval(h);
  },[playing, playlist.length, currentIdx, auto, caps.showPlaylist]);

  /* ðŸ‘‰ Viertelkreis: von SÃ¼d (0,R) nach West (-R,0), sweep=1 â†’ unten links */
  function stagePath(){
    const s = { x: 0,  y: R };
    const e = { x: -R, y: 0 };
    return `M ${s.x} ${s.y} A ${R} ${R} 0 0 1 ${e.x} ${e.y} L 0 0 Z`;
  }

  function toSvgPoint(evt){
    const svg = svgRef.current, rect = svg.getBoundingClientRect();
    const px = evt.clientX - rect.left, py = evt.clientY - rect.top;
    const x = VIEWBOX.x + (px/rect.width)*VIEWBOX.w, y = VIEWBOX.y + (py/rect.height)*VIEWBOX.h;
    return {x,y};
  }

  /* Dragâ€‘Grenzen: x âˆˆ [-m,0], y âˆˆ [0,m] */
  function constrain(x, y){
    const m = R + 120;
    return { x: clamp(x, -m, 0), y: clamp(y, 0, m) };
  }

  /* Gemeinsamer SVGâ€‘MouseMove: Drag, Rotation, Hover */
  function onSvgMove(e){
    const p = toSvgPoint(e);

    // 1) Rotation aktiv?
    if (rotId && caps.canEdit) {
      setLights(ls => ls.map(l => {
        if (l.id !== rotId) return l;
        // Handleâ€‘Winkel = Winkel vom Spot zum Mauszeiger
        const handleDeg = angleFromPoint(l.x, l.y, p.x, p.y);
        // Beam zeigt genau GEGENÃœBER des Handles:
        const newDir = (handleDeg + 180) % 360;
        return { ...l, dirDeg: newDir };
      }));
      return;
    }

    // 2) Drag aktiv?
    if (dragId && caps.canEdit) {
      const c = constrain(p.x, p.y);
      setLights(ls=>ls.map(l=>l.id===dragId? {...l, x:c.x, y:c.y,
        // beim Verschieben: Richtung standardmÃ¤ÃŸig weiterhin zum Zentrum,
        // auÃŸer der User rotiert danach manuell.
        dirDeg: (toDeg(Math.atan2(-c.y, -c.x)) + 360) % 360
      }:l));
      return;
    }

    // 3) Hoverâ€‘Erkennung (nur wenn nichts aktiv)
    const near = 24; // Weltâ€‘Einheiten (ca. Pixel)
    let h = null, best = Infinity;
    for (const l of lights) {
      const d = Math.hypot(l.x - p.x, l.y - p.y);
      if (d < near && d < best) { best = d; h = l.id; }
    }
    setHoverId(h);
  }

  function onUp(){ if(dragId) setDragId(null); if (rotId) setRotId(null); }

  function exportFull(){
    const blob = new Blob([JSON.stringify({theme,lights,scenes,playlist},null,2)], {type:"application/json"});
    const url = URL.createObjectURL(blob); const a = document.createElement("a");
    a.href=url; a.download="stage_full_export.json"; a.click(); URL.revokeObjectURL(url);
  }
  function importFull(file){
    const r = new FileReader();
    r.onload = ()=>{
      try{
        const data = JSON.parse(r.result);
        if(data.theme) setTheme(data.theme);
        if(Array.isArray(data.lights)) setLights(data.lights);
        if(Array.isArray(data.scenes)) setScenes(data.scenes);
        if(Array.isArray(data.playlist)) setPlaylist(data.playlist);
      }catch{ alert("UngÃ¼ltige Datei"); }
    };
    r.readAsText(file);
  }

  async function sendDMX(channels){
    try{
      await fetch("/api/dmx", {
        method:"POST", headers:{"Content-Type":"application/json"},
        body: JSON.stringify({channels})
      });
    }catch(e){ console.warn("DMX send failed", e); }
  }

  useEffect(()=>{
    if(mode==="show" || mode==="guest") return;
    const ch = buildDMXChannels(lights);
    sendDMX(ch);
  },[lights, mode]);

  function guestApply(name){
    const s = scenes.find(sc=>sc.name===name);
    if(s){ applyScene(s.id); }
  }

  const selected = useMemo(()=> lights.find(l=>l.id===selectedId) || null, [lights,selectedId]);
  const leftHidden = (mode==="show" || mode==="guest");

  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="pill">Viertelkreis r=4m</div>
          <div className="pill">{mode.toUpperCase()}</div>
        </div>
        <div className="flex items-center gap-2">
          <label className="text-sm">Theme</label>
          <select className="btn" value={theme} onChange={e=>setTheme(e.target.value)}>
            {THEMES.map(t=><option key={t} value={t}>{t}</option>)}
          </select>
          { (mode!=="show" && mode!=="guest") && (
            <>
              <button className="btn" onClick={exportFull}>Export (alles)</button>
              <label className="btn cursor-pointer">Import
                <input type="file" accept="application/json" className="hidden"
                  onChange={e=> e.target.files?.[0] && importFull(e.target.files[0])}/>
              </label>
            </>
          )}
        </div>
      </div>

      <div className="flex gap-2">
        {MODES.map(m => (
          <button key={m} className={`btn ${mode===m?'border-indigo-400/60':''}`} onClick={()=>setMode(m)}>{m}</button>
        ))}
      </div>

      <div className={`gap-4 ${leftHidden? 'grid2' : ( (mode==="probe") ? 'grid3' : 'grid2')}`}>
        {!leftHidden && (
          <div className="card">
            <div className="text-lg mb-2">{mode==="editor"?"Editor":"Probephase"}</div>
            <div className={`grid2 ${!caps.canEdit?'muted':''}`}>
              {lights.map(l=>(
                <button key={l.id} className={`kachel text-left ${selectedId===l.id?'border-indigo-400/60':''}`} onClick={()=>setSelectedId(l.id)}>
                  <div className="font-medium">{l.label}</div>
                  <div className="text-xs opacity-75">Typ {l.type} Â· DMX {l.dmx.start}</div>
                  <div className="text-xs mt-1">Brightness {l.brightness}%</div>
                </button>
              ))}
            </div>

            {selected && (
              <div className={`mt-3 card ${!caps.canEdit?'muted':''}`}>
                <div className="flex gap-2 items-center">
                  <input className="btn" value={selected.label} onChange={e=>renameLight(selected.id, e.target.value)} />
                  <select className="btn" value={selected.type} onChange={e=>setType(selected.id, e.target.value)}>
                    {TYPES.map(t=><option key={t} value={t}>{t}</option>)}
                  </select>
                  <div className="ml-auto text-sm">{selected.brightness}%</div>
                </div>
                <input type="range" min="0" max="100" value={selected.brightness} onChange={e=>setBrightness(selected.id, e.target.value)} className="w-full mt-2"/>
                {selected.type==="RGB" && (
                  <div className="grid3 mt-2">
                    {["r","g","b"].map(ch=>(
                      <div key={ch} className="card">
                        <div className="text-xs mb-1">{ch.toUpperCase()}</div>
                        <input type="range" min="0" max="255" value={selected[ch]} onChange={e=>setRGB(selected.id, ch, e.target.value)} className="w-full"/>
                        <div className="text-right text-xs">{selected[ch]}</div>
                      </div>
                    ))}
                  </div>
                )}
                <div className="grid3 mt-2">
                  <label className="text-xs">U <input type="number" className="btn ml-1 w-20" value={selected.dmx.universe} onChange={e=>setDMX(selected.id,{universe:Number(e.target.value)})}/></label>
                  <label className="text-xs">Start <input type="number" className="btn ml-1 w-24" value={selected.dmx.start} onChange={e=>setDMX(selected.id,{start:Number(e.target.value)})}/></label>
                  <label className="text-xs">Mode <input type="text" className="btn ml-1 w-24" value={selected.dmx.mode} onChange={e=>setDMX(selected.id,{mode:e.target.value})}/></label>
                </div>
              </div>
            )}

            <div className={`mt-3 card ${!caps.sceneSaveDelete?'muted':''}`}>
              <div className="text-md mb-2">Szenen</div>
              {caps.sceneSaveDelete && <SceneCreator onSave={saveScene}/>}
              <div className="mt-2" style={{maxHeight:240, overflow:"auto"}}>
                {scenes.map(s=>(
                  <div key={s.id} className="flex gap-2 items-center border border-slate-700 rounded-lg p-2 mb-2">
                    <div className="font-medium">{s.name}</div>
                    <div className="ml-auto flex gap-2">
                      <button className="btn" onClick={()=>applyScene(s.id)}>Laden</button>
                      {caps.addRemove && <button className="btn" onClick={()=>addToPlaylist(s.id)}>+ Playlist</button>}
                      {caps.sceneSaveDelete && <button className="btn" onClick={()=>deleteScene(s.id)}>LÃ¶schen</button>}
                    </div>
                  </div>
                ))}
                {scenes.length===0 && <div className="text-xs opacity-70">Noch keine Szenen.</div>}
              </div>
            </div>
          </div>
        )}

        <div className="card">
          <div className="text-sm mb-2">BÃ¼hne (Viertelkreis r={RADIUS_M}m)</div>
          <div className="relative w-full" style={{aspectRatio:"1/1"}}>
            <svg ref={svgRef}
                 viewBox={`${VIEWBOX.x} ${VIEWBOX.y} ${VIEWBOX.w} ${VIEWBOX.h}`}
                 onMouseMove={onSvgMove} onMouseUp={onUp} onMouseLeave={onUp}
                 style={{width:"100%", height:"100%"}}>
              <defs>
                <radialGradient id="stageGrad" cx="0" cy="0" r="1">
                  <stop offset="0%" stopColor={"#303446"}></stop>
                  <stop offset="100%" stopColor={"#1e293b"}></stop>
                </radialGradient>

                {/* Farbkegel pro Lampe */}
                {lights.map(l=>(
                  <radialGradient key={`beam-${l.id}`} id={`beam-${l.id}`} cx="0" cy="0" r="1">
                    <stop offset="0%" stopColor={beamColor(l)} stopOpacity="0.9"></stop>
                    <stop offset="40%" stopColor={beamColor(l)} stopOpacity={0.45*(l.brightness/100)}></stop>
                    <stop offset="100%" stopColor={beamColor(l)} stopOpacity="0"></stop>
                  </radialGradient>
                ))}

                {/* Pfeilspitzen fÃ¼r den Rotationsâ€‘Ring */}
                <marker id="arrow-tip" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8"/>
                </marker>
              </defs>

              {/* BÃ¼hne: linker unterer Viertelkreis */}
              <path d={stagePath()} fill="url(#stageGrad)" stroke="#475569" strokeWidth="2"/>

              {/* Gestrichelter Hilfsbogen links */}
              <path
                d={`M 0 ${R + 40} A ${R + 40} ${R + 40} 0 0 1 ${-R - 40} 0`}
                stroke="#64748b" strokeWidth="2" fill="none" strokeDasharray="6 6"
              />

              {/* Lichtkegel + Spot + Drehâ€‘UI */}
              {lights.map(l=>{
                const bs = l.brightness/100;

                // Beamâ€‘Richtung aus dirDeg
                const a = toRad(l.dirDeg);
                const ux = Math.cos(a), uy = Math.sin(a);

                // Spread (Ã–ffnungswinkel)
                const spread = 18*Math.PI/180, half=spread/2, bl = (R*0.9)*(0.6+0.4*bs);
                const c1 = Math.cos(-half), s1=Math.sin(-half), c2=Math.cos(half), s2=Math.sin(half);
                const rx1=ux*c1-uy*s1, ry1=ux*s1+uy*c1, rx2=ux*c2-uy*s2, ry2=ux*s2+uy*c2;
                const p0={x:l.x,y:l.y}, p1={x:l.x+rx1*bl, y:l.y+ry1*bl}, p2={x:l.x+rx2*bl, y:l.y+ry2*bl};

                // Drehâ€‘UI: Handle auf der GEGENSEITE (180Â° versetzt)
                const handleDeg = (l.dirDeg + 180) % 360;
                const ringR = 36;
                const arcA1 = (handleDeg - 90 + 360) % 360;
                const arcA2 = (handleDeg + 90) % 360;
                const handlePos = pointOnCircle(l.x, l.y, ringR, handleDeg);
                const arcD = arcPath(l.x, l.y, ringR, arcA1, arcA2);
                const showRing = (hoverId === l.id) || (selectedId === l.id);

                return (
                  <g key={l.id}>
                    {/* Beam */}
                    <path d={`M ${p0.x} ${p0.y} L ${p1.x} ${p1.y} L ${p2.x} ${p2.y} Z`}
                          fill={`url(#beam-${l.id})`}
                          style={{mixBlendMode:"lighten", opacity: (bs>0)? (0.18 + bs*0.6): 0}}/>

                    {/* Rotationsâ€‘Ring (nur bei Hover/Selektion) */}
                    {showRing && (
                      <>
                        <path d={arcD}
                              stroke="#94a3b8" strokeWidth="2" fill="none"
                              markerStart="url(#arrow-tip)"
                              markerEnd="url(#arrow-tip)"/>
                        {/* Klickâ€‘/Dragâ€‘FlÃ¤che auf dem Ring */}
                        <path d={arcD}
                              stroke="transparent" strokeWidth="14" fill="none"
                              style={{cursor:"grab"}}
                              onMouseDown={(e)=>{ if(!caps.canEdit) return; e.stopPropagation(); e.preventDefault(); setRotId(l.id); }}/>
                        {/* Handle */}
                        <circle cx={handlePos.x} cy={handlePos.y} r="6"
                                fill="#0f172a" stroke="#94a3b8" strokeWidth="2"
                                style={{cursor:"grab"}}
                                onMouseDown={(e)=>{ if(!caps.canEdit) return; e.stopPropagation(); e.preventDefault(); setRotId(l.id); }}/>
                      </>
                    )}

                    {/* Spotâ€‘Kreis (Drag) */}
                    <g onMouseDown={(e)=>{ if(!caps.canEdit) return; e.stopPropagation(); setDragId(l.id); }}
                       cursor={caps.canEdit? "grab":"default"}>
                      <circle cx={l.x} cy={l.y} r={8} stroke="#cbd5e1" strokeWidth="2" fill="#0f172a"/>
                    </g>

                    {/* Label */}
                    <text x={l.x+12} y={l.y-6} fontSize="10" fill="#cbd5e1">{l.label}</text>
                  </g>
                );
              })}

              {/* Achsen/Kanten: links unten */}
              <line x1="0" y1="-10" x2="0" y2={R} stroke="#334155" strokeWidth="2"/>
              <line x1={-R} y1="0" x2="0" y2="0" stroke="#334155" strokeWidth="2"/>
            </svg>
          </div>

          {mode==="guest" ? (
            <div className="mt-3 grid2">
              {["Party","Wohnzimmer Konzert 1","Rock Konzert","Arbeitslicht"].map(name => (
                <button key={name} className="kachel" onClick={()=>guestApply(name)}>{name}</button>
              ))}
            </div>
          ) : (
            caps.playerControls && (
              <div className="mt-3 card">
                <div className="flex items-center gap-2">
                  <button className="btn" onClick={()=>{ if(!playlist.length) return; setPlaying(p=>!p); if(!playing) applyPlaylistIndex(currentIdx); }}>{playing?"Pause":"Play"}</button>
                  <button className="btn" onClick={()=>applyPlaylistIndex(currentIdx)}>Aktuelle anwenden</button>
                  <button className="btn" onClick={prevScene}>ZurÃ¼ck</button>
                  <button className="btn" onClick={nextScene}>Weiter</button>
                  <div className="ml-auto flex items-center gap-2">
                    <span className="text-sm">Auto (s)</span>
                    <input type="number" min="1" className="btn" style={{width:80}} value={auto} onChange={e=>caps.autoEdit && setAuto(Number(e.target.value)||5)} disabled={!caps.autoEdit}/>
                    {caps.addRemove && <button className="btn" onClick={clearPlaylist}>Clear</button>}
                  </div>
                </div>

                {(mode!=="editor") && (
                  <div className={`mt-3 ${!caps.reorder?'muted':''}`} style={{maxHeight:240, overflow:"auto"}}>
                    {playlist.length===0 && <div className="text-xs opacity-70">Keine EintrÃ¤ge. FÃ¼ge im Tab â€žProbephaseâ€œ Ã¼ber â€ž+ Playlistâ€œ hinzu.</div>}
                    {playlist.map((p,idx)=>(
                      <div key={p.pid} draggable={caps.reorder}
                           onDragStart={(e)=>onDragStart(e,p.pid)}
                           onDragOver={(e)=>onDragOver(e,p.pid)} onDrop={onDrop}
                           className={`flex items-center gap-2 border border-slate-700 rounded-lg p-2 mb-2 ${idx===currentIdx?'border-indigo-400/60':''}`}>
                        <div className="pill">{idx+1}</div>
                        <div className="flex-1">{p.name}</div>
                        <button className="btn" onClick={()=>applyPlaylistIndex(idx)}>Go</button>
                        {caps.addRemove && <button className="btn" onClick={()=>rmFromPlaylist(p.pid)}>Entfernen</button>}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )
          )}
        </div>

        {(!leftHidden && mode==="probe") && (
          <div className="card">
            <div className="text-md mb-2">Szenen (â†’ Playlist)</div>
            <div style={{maxHeight:520, overflow:"auto"}}>
              {scenes.map(s=>(
                <div key={s.id} className="flex items-center gap-2 border border-slate-700 rounded-lg p-2 mb-2">
                  <div className="font-medium">{s.name}</div>
                  <div className="ml-auto flex gap-2">
                    <button className="btn" onClick={()=>applyScene(s.id)}>Laden</button>
                    <button className="btn" onClick={()=>addToPlaylist(s.id)}>+ Playlist</button>
                  </div>
                </div>
              ))}
              {scenes.length===0 && <div className="text-xs opacity-70">Keine Szenen vorhanden.</div>}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

function SceneCreator({onSave}){
  const [name,setName] = React.useState("");
  return (
    <div className="flex gap-2 items-center">
      <input className="btn flex-1" placeholder="Szenennameâ€¦" value={name} onChange={e=>setName(e.target.value)}/>
      <button className="btn" onClick={()=>{ onSave(name.trim()); setName(""); }}>Speichern</button>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('app')).render(<App/>);
  </script>
</body>
</html>
